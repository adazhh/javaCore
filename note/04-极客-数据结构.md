# 数据结构

[TOC]



## 基础数据结构

### 1. 数组

#### 1.1 定义

数组是一种**线性**表数据结构，它用一组**连续的内存空间**，来存储**相同类型**的数据。

最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)。

##### 集合和数组的区别

ArrayList只支持对象，数组既可以存储基本数据类型，也可以存储对象；集合可以动态扩容，并且封装了很多操作

##### 数组和链表的比较

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读

和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。

##### 数组为什么要从0开始编号

a[0]表示的是首地址，a[k]就表示偏移k个位置的地址，就算a[k]的内存地址只需要该公式：a[k] = a[0] + k * type_size；如果从1开始，则是a[k] = a[0] + (k - 1) * type_size，对CPU来说需要多进行一次减法运算。（不过真正的原因可能是历史原因）

// 二维数组的内存寻址：对于m * n数组，a[i] [j] （i<m, j<n)的地址为a[k] = a[0] + ( i * n + j) * type_size 

### 2. 链表

#### 2.1 定义

通过指针将零散的内存块串联起来使用，普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。

和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。

##### tips：写链表需要注意的问题

1. 警惕指针丢失和内存泄漏（删除时手动释放节点）
2. 边界问题
3. 使用哨兵来简化代码（设置一个头节点）

#### 2.2 缓存套测策略

1. 先进先出策略（FIFO First In First Out)

2. 最少使用策略（LFU Least Frequently Used)

3. 最近最少使用策略（LRU Least Recently Used）

   最新访问的元素放到头节点

### 3. 栈

#### 定义

**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据，先进后出，后进先出

从功能上来说，数组或链表可以替代栈，但是特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

### 4. 队列

队列跟栈一样，也是一种**操作受限的线性表数据结构**。只有入队和出队两种操作，先进先出

队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。

### 5. 递归

#### 定义

递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。
方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。

#### 什么时候可以使用递归

一个问题只要同时满足以下3个条件，就可以用递归来解决：
1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。
2.问题与子问题，除了数据规模不同，求解思路完全一样
3.存在递归终止条件

#### 递归的优点和缺点

优点：代码的表达力很强，写起来简洁。
缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题

警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。

#### 如何将递归改写为非递归代码？

笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。  

### 6. 排序

#### 6.1 排序方法分类

排序方法与复杂度归类
（1）几种最经典、最常用的排序方法：冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。
（2）复杂度归类
冒泡排序、插入排序、选择排序 O(n^2)
快速排序、归并排序 O(nlogn)
计数排序、基数排序、桶排序 O(n)
（3）排序算法分析
时间复杂度、空间复杂度、稳定性

#### 6.2 冒泡，插入，选择

<img src="D:\myCode\javaCore\note\notePic\1570450598983.png" alt="1570450598983" style="zoom: 25%;" />

冒泡排序和选择排序基本上只是理论上存在，很少被使用。

##### 冒泡排序和插入排序的性能比较

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，所以在对相同数组进行排序时，冒泡排序的运行时间理论上要长于插入排序。

#### 6.3 归并排序和快速排序

查用排序算法，适合大规模数据的排序。

两者都是使用了分治思想。分治是解决问题的处理思想，递归是一种编程技巧。

归并排序的处理过程是**由下到上**的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是**由上到下**的，先分区，然后再处理子问题。

归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和merge()合并函数。同理，理解快排的重点也是理解递推公式，还有partition()分区函数。

归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法O(nlogn)，这也使它存在致命的缺点，即归并排序不是原地排序算法，**空间复杂度比较高**，是O(n)。正因为此，它也没有快排应用广泛。快速排序算法虽然最坏情况下的时间复杂度是O(n2)，但是平均情况下和最好情况下时间复杂度都是O(nlogn)。不仅如此，快速排序算法时间复杂度退化到O(n2)的**概率非常小**，我们可以通过合理地选择pivot来避免这种情况。

##### 优化快速排序

选择合适的分区点

1. 三数取中法（取几个数据比较，去中间值）
2. 随机法（随机选择一个数据，退化为n^2的概率小）

#### 6.4 线性排序-桶排序、计数排序、基数排序

##### 6.4.1 桶排序

1. 算法原理：
   1）将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序。
   2）桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
2. 使用条件
   1）要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。
   2）数据在各个桶之间分布是均匀的。
3. 适用场景
   1）桶排序比较适合用在外部排序中。
   2）外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中。

##### 6.4.2 计数排序

1. 算法原理
   1）计数其实就是桶排序的一种特殊情况。
   2）当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶
   3）每个桶内的数据值都是相同的，就省掉了桶内排序的时间。
2. 使用条件
   1）只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序；
   2）计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数；
   3）比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数。

##### 6.4.3 基数排序

1. 算法原理（以排序10万个手机号为例来说明）
   1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
   2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
   3）经过11次排序后，手机号码就变为有序的了。
   4）每次排序有序数据范围较小，可以使用桶排序或计数排序来完成。
2. 使用条件
   1）要求数据可以分割独立的“位”来比较；
   2）位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了；
   3）每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)。

#### 6.4.5 排序总结

<img src="C:\Users\阿打\AppData\Roaming\Typora\typora-user-images\1570453027951.png" alt="1570453027951" style="zoom:25%;" />

1.在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序
2.数据量不大时，可以采取用时间换空间的思路（归并排序）
3.数据量大时，优化快排分区点的选择
4.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决
5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致

### 7. 二分查找

#### 使用条件（应用场景的局限性）
1.二分查找依赖的是顺序表结构，即数组。
2.二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。
3.**数据量太小不适合二分查找**，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。
4.**数据量太大也不是适合用二分查找**，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。

### 8. 跳表

跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是O(logn)。

跳表的空间复杂度是O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表

##### 高效的动态插入和删除？

跳表本质上就是链表，所以仅插作，插入和删除操时间复杂度就为O(1)，但在实际情况中，要插入或删除某个节点，需要先查找到指定位置，而这个查找操作比较费时，但在跳表中这个查找操作的时间复杂度是O(logn)，所以，跳表的插入和删除操作的是时间复杂度也是O(logn)。

##### 跳表索引动态更新？

当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中，那么如何选择这个索引层呢？可以通过随机函数来决定将这个节点插入到哪几级索引中，比如随机函数生成了值K，那就可以把这个节点添加到第1级到第K级索引中。

### 9. 散列表

散列表来源于数组，用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

#### 散列冲突和散列函数

散列函数：非负整数

散列冲突：

1. 开放寻址法：如果出现散列冲突，就重新探测一个空闲位置，将其插入。

   1.线性探测 2.二次探测 3.双重探测

2. 链表法（最常用）